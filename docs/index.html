<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>API Reference</title>

    <link href="stylesheet/style.css" rel="stylesheet" />
    <link href="stylesheet/screen.css" rel="stylesheet" media="screen" />
    <link href="stylesheet/print.css" rel="stylesheet" media="print" />
    <link href="stylesheet/prism.css" rel="stylesheet" />
    <script src="javascripts/all_nosearch.js"></script>
</head>


    <body class="index" data-languages="[]">
    <a href="#" id="nav-button">
    <span>
        NAV
        <img src="images/navbar.png" alt="Navbar" />
    </span>
</a>

    <div class="toc-wrapper">
    <img src="images/logo.png" class="logo" alt="Logo" />
    <div id="toc" class="toc-list-h1">
        
    <li>
        <a href="#Introduction" class="toc-h1 toc-link" data-title="Introduction">Introduction</a>
    
    </li>

    <li>
        <a href="#API" class="toc-h1 toc-link" data-title="API">API</a>
    
                <ul class="toc-list-h2">
                    
    <li>
        <a href="#JSON" class="toc-h2 toc-link" data-title="JSON">JSON</a>
    
    </li>

    <li>
        <a href="#YAML" class="toc-h2 toc-link" data-title="YAML">YAML</a>
    
    </li>

    <li>
        <a href="#Binary" class="toc-h2 toc-link" data-title="Binary">Binary</a>
    
    </li>

    <li>
        <a href="#Macros" class="toc-h2 toc-link" data-title="Macros">Macros</a>
    
    </li>

    <li>
        <a href="#Exporter" class="toc-h2 toc-link" data-title="Exporter">Exporter</a>
    
    </li>

    <li>
        <a href="#Importer" class="toc-h2 toc-link" data-title="Importer">Importer</a>
    
    </li>



                </ul>
    
    </li>

    <li>
        <a href="#Usage" class="toc-h1 toc-link" data-title="Usage">Usage</a>
    
                <ul class="toc-list-h2">
                    
    <li>
        <a href="#Serializing" class="toc-h2 toc-link" data-title="Serializing">Serializing</a>
    
                <ul class="toc-list-h3">
                    
    <li>
        <a href="#Format" class="toc-h3 toc-link" data-title="Format">Format</a>
    
    </li>

    <li>
        <a href="#Strictness" class="toc-h3 toc-link" data-title="Strictness">Strictness</a>
    
    </li>

    <li>
        <a href="#Exceptions" class="toc-h3 toc-link" data-title="Exceptions">Exceptions</a>
    
    </li>



                </ul>
    
    </li>

    <li>
        <a href="#Declarations" class="toc-h2 toc-link" data-title="Declarations">Declarations</a>
    
                <ul class="toc-list-h3">
                    
    <li>
        <a href="#StandardTypes" class="toc-h3 toc-link" data-title="Standard Types">Standard Types</a>
    
    </li>

    <li>
        <a href="#StandardContainers" class="toc-h3 toc-link" data-title="Standard Containers">Standard Containers</a>
    
    </li>

    <li>
        <a href="#Enum" class="toc-h3 toc-link" data-title="Enum">Enum</a>
    
    </li>

    <li>
        <a href="#Structure" class="toc-h3 toc-link" data-title="Structure">Structure</a>
    
    </li>

    <li>
        <a href="#Pointers" class="toc-h3 toc-link" data-title="Pointers">Pointers</a>
    
    </li>

    <li>
        <a href="#Value" class="toc-h3 toc-link" data-title="Value">Value</a>
    
    </li>



                </ul>
    
    </li>



                </ul>
    
    </li>

    <li>
        <a href="#Implementation" class="toc-h1 toc-link" data-title="Implementation">Implementation</a>
    
                <ul class="toc-list-h2">
                    
    <li>
        <a href="#Traits" class="toc-h2 toc-link" data-title="Traits">Traits</a>
    
                <ul class="toc-list-h3">
                    
    <li>
        <a href="#TraitsValue" class="toc-h3 toc-link" data-title="Traits Value">Traits Value</a>
    
    </li>

    <li>
        <a href="#TraitsEnum" class="toc-h3 toc-link" data-title="Traits Enum">Traits Enum</a>
    
    </li>

    <li>
        <a href="#TraitsSerialize" class="toc-h3 toc-link" data-title="Traits Serialize">Traits Serialize</a>
    
    </li>

    <li>
        <a href="#TraitsPointer" class="toc-h3 toc-link" data-title="Traits Pointer">Traits Pointer</a>
    
    </li>

    <li>
        <a href="#TraitsMap" class="toc-h3 toc-link" data-title="Traits Map">Traits Map</a>
    
    </li>

    <li>
        <a href="#TraitsArray" class="toc-h3 toc-link" data-title="Traits Array">Traits Array</a>
    
    </li>



                </ul>
    
    </li>



                </ul>
    
    </li>

    <li>
        <a href="#APiGenerated" class="toc-h1 toc-link" data-title="APi Generated">APi Generated</a>
    
                <ul class="toc-list-h2">
                    
    <li>
        <a href="#binExport" class="toc-h2 toc-link" data-title="binExporter">binExporter</a>
    
                <ul class="toc-list-h3">
                    


                </ul>
    
    </li>

    <li>
        <a href="#binImporter" class="toc-h2 toc-link" data-title="binImporter">binImporter</a>
    
                <ul class="toc-list-h3">
                    


                </ul>
    
    </li>

    <li>
        <a href="#jsonExporter" class="toc-h2 toc-link" data-title="jsonExporter">jsonExporter</a>
    
                <ul class="toc-list-h3">
                    


                </ul>
    
    </li>

    <li>
        <a href="#jsonImporter" class="toc-h2 toc-link" data-title="jsonImporter">jsonImporter</a>
    
                <ul class="toc-list-h3">
                    


                </ul>
    
    </li>

    <li>
        <a href="#yamlExporter" class="toc-h2 toc-link" data-title="yamlExporter">yamlExporter</a>
    
                <ul class="toc-list-h3">
                    


                </ul>
    
    </li>

    <li>
        <a href="#yamlImporter" class="toc-h2 toc-link" data-title="yamlImporter">yamlImporter</a>
    
                <ul class="toc-list-h3">
                    


                </ul>
    
    </li>



                </ul>
    
    </li>



    </div>
    <ul class="toc-footer">
        <li><a href="">Generated by Andvari</a><br>
            <a href="https://github.com/Loki-Astari/andvari-theme-documentation">using andvari-theme-documentation</a>
        </li>
    </ul>
</div>

    <div class="page-wrapper">
    <div class="dark-box"></div>
    <div class="content">
        
    
    <h1 id="Introduction">Introduction</h1>
    
        <p><a href="https://github.com/Loki-Astari/ThorsSerializer">ThorsSerializer</a> A modern  declarative C++ serialization library.</p>

    
    

    
    <h1 id="API">API</h1>
    
        

    
    
        
    
    <h2 id="JSON">JSON</h2>
    
        
<dl>
<dt>NameSpace:</dt><dd>ThorsAnvil::Serialize</dd>
<dt>Headers:</dt><dd>ThorSerialize/JsonThor.h</dd>

    
        <dt></dt><dd>
            <ul>
            
            
                
                    <li>Exporter&lt;T, Json&gt; jsonExporter
                    
                    ( T const& value )
                    
                    </li>
                
                    <li>Importer&lt;T, Json&gt; jsonImporter
                    
                    ( T& value )
                    
                    </li>
                
            
            </ul>
        </dd>
    

</dl>


    
    

    
    <h2 id="YAML">YAML</h2>
    
        
<dl>
<dt>NameSpace:</dt><dd>ThorsAnvil::Serialize</dd>
<dt>Headers:</dt><dd>ThorSerialize/YamlThor.h</dd>

    
        <dt></dt><dd>
            <ul>
            
            
                
                    <li>Exporter&lt;T, Yaml&gt; yamlExporter
                    
                    ( T const& value )
                    
                    </li>
                
                    <li>Importer&lt;T, Yaml&gt; yamlImporter
                    
                    ( T& value )
                    
                    </li>
                
            
            </ul>
        </dd>
    

</dl>


    
    

    
    <h2 id="Binary">Binary</h2>
    
        
<dl>
<dt>NameSpace:</dt><dd>ThorsAnvil::Serialize</dd>
<dt>Headers:</dt><dd>ThorSerialize/BinaryThor.h</dd>

    
        <dt></dt><dd>
            <ul>
            
            
                
                    <li>Exporter&lt;T, Binary&gt; binaryExporter
                    
                    ( T const& value )
                    
                    </li>
                
                    <li>Importer&lt;T, Binary&gt; binaryImporter
                    
                    ( T& value )
                    
                    </li>
                
            
            </ul>
        </dd>
    

</dl>


    
    

    
    <h2 id="Macros">Macros</h2>
    
        
<dl>
<dt>NameSpace:</dt><dd></dd>
<dt>Headers:</dt><dd>ThorSerialize/Traits.h</dd>

    
        <dt></dt><dd>
            <ul>
            
            
                
                    <li> ThorsAnvil_MakeEnum
                    
                    ( EnumType,EnumValues... )
                    
                    </li>
                
                    <li> ThorsAnvil_MakeTraitCustom
                    
                    ( Type )
                    
                    </li>
                
                    <li> ThorsAnvil_PointerAllocator
                    
                    ( Type,Action )
                    
                    </li>
                
                    <li> ThorsAnvil_MakeTrait
                    
                    ( Type,fields... )
                    
                    </li>
                
                    <li> ThorsAnvil_ExpandTrait
                    
                    ( ParentType,Type,fields... )
                    
                    </li>
                
                    <li> ThorsAnvil_Template_MakeTrait
                    
                    ( TemplateParameterCount,Type,fields... )
                    
                    </li>
                
                    <li> ThorsAnvil_Template_ExpandTrait
                    
                    ( TemplateParameterCount,ParentType,Type,fields... )
                    
                    </li>
                
                    <li> ThorsAnvil_PolyMorphicSerializer
                    
                    ( Type )
                    
                    </li>
                
                    <li> ThorsAnvil_RegisterPolyMorphicType
                    
                    ( Type )
                    
                    </li>
                
            
            </ul>
        </dd>
    

</dl>


    
    

    
    <h2 id="Exporter">Exporter</h2>
    
        
<dl>
<dt>NameSpace:</dt><dd>ThorsAnvil::Serialize</dd>
<dt>Headers:</dt><dd>ThorSerialize/Exporter.h</dd>

    
        <dt></dt><dd>
            <ul>
            
            
                
                    <li>std::ostream& operator&lt;<
                    
                    ( std::ostream& stream,Exporter const& data )
                    
                    </li>
                
            
            </ul>
        </dd>
    

</dl>


    
    

    
    <h2 id="Importer">Importer</h2>
    
        
<dl>
<dt>NameSpace:</dt><dd>ThorsAnvil::Serialize</dd>
<dt>Headers:</dt><dd>ThorSerialize/Importer.h</dd>

    
        <dt></dt><dd>
            <ul>
            
            
                
                    <li>std::istream& operator&gt;>
                    
                    ( std::istream& stream,Importer const& data )
                    
                    </li>
                
            
            </ul>
        </dd>
    

</dl>


    
    


    

    
    <h1 id="Usage">Usage</h1>
    
        

    
    
        
    
    <h2 id="Serializing">Serializing</h2>
    
        <p>There are two serialization formats supported out o the box (JSON/YAML) and an experimental binary format (I would love if somebody added the google Protocol Buffers).</p>
<pre><code class="C++ language-C++">#include "ThorSerialize/JsonThor.h"

using ThorsAnvil::Serialize::jsonExporter;
using ThorsAnvil::Serialize::jsonImporter;

int main()
{
    std::cout &lt;&lt; jsonExporter(12) &lt;&lt; "\n";

    int value;
    std::cin &gt;&gt; jsonImporter(value);
}</code></pre>
<p>Each format has two commands <code>&lt;format&gt;Importer(&lt;object&gt;)</code> and <code>&lt;format&gt;Exporter(&lt;object&gt;)</code>. e.g. <code>jsonExporter(12)</code>.</p>
<p>These functions return a very lightweight object (it simply contains a reference to the object being serialized) that can be passed to the standard stream operators. Thats at it for a the user of serialization library.</p>
<p>To include all the functionality all you need to do is include <code>#include "ThorSerialize/&lt;format&gt;Thor.h"</code> and link against <code>libThorSerialize.so</code>.</p>

    
    
        
    
    <h3 id="Format">Format</h3>
    
        <pre><code class="C++ language-C++">    std::cout &lt;&lt; jsonExporter(mark) &lt;&lt; "\n";
...
    {
        "name": "mark",
        "score": 10,
        "damage": 5,
        "team":
        {
            "red": 66,
            "green": 42,
            "blue": 23
        }
    }
...
    using OutputType = ThorsAnvil::Serialize::PrinterInterface::OutputType;
    std::cout &lt;&lt; jsonExporter(mark, OutputType::Stream) &lt;&lt; "\n";
...
{"name":"mark","score":10,"damage":5,"team":{"red":66,"green":42,"blue":23}}</code></pre>
<p>By default the generated JSON is verbose and easy for humans to read. This also makes it longer than required. You can compact the output by <code>OutputType::Stream</code> in the <code>jsonFormat()</code>.</p>

    
    

    
    <h3 id="Strictness">Strictness</h3>
    
        <pre><code class="C++ language-C++">    std::cin &lt;&lt; jsonImporter(dst) &lt;&lt; "\n";
...
    using ParseType = ThorsAnvil::Serialize::ParserInterface::ParseType;
    std::cin &gt;&gt; jsonImporter(dst, ParseType::Strict);</code></pre>
<p>By default the parser is forgiving; extra or missing fields are simply ignored. If you want to use <strong>Strict</strong> parsing then you specify this as part of the <code>jsonImporter()</code>. In this mode all fields are required no additional fields are allowed. If either of these constraints are broken then an exception is thrown.</p>

    
    

    
    <h3 id="Exceptions">Exceptions</h3>
    
        <pre><code class="C++ language-C++">    using OutputType = ThorsAnvil::Serialize::PrinterInterface::OutputType;
    while(std::cout &lt;&lt; jsonExporter(12, OutputType::Default, true) &lt;&lt; "\n")
    {
        // Successfully wrote an object to the output
    }
    ...
    using ParseType = ThorsAnvil::Serialize::ParserInterface::ParseType;
    while(std::cin &gt;&gt; jsonImporter(dst, ParseType::Weak, true))
    {
        // Successfully read an object from the input
    }</code></pre>
<p>By default the ThorsSerializer will throw an exception when it encounters a parsing error (it also sets the stream state to fail). If you would prefer for the stream to swallow the exception (but still set the stream state to fail) then you can modify this behavior in <code>jsonImporter()</code> and <code>jsonExporter()</code>.</p>

    
    


    

    
    <h2 id="Declarations">Declarations</h2>
    
        

    
    
        
    
    <h3 id="StandardTypes">Standard Types</h3>
    
        <pre><code class="C++ language-C++">#include "ThorSerialize/JsonThor.h"

using ThorsAnvil::Serialize::jsonExporter;
using ThorsAnvil::Serialize::jsonImporter;

int main()
{
    int         v1 = 12;        // All the different types of int are supported)
    double      v2 = 13.5;      // float/double/long double all supported
    bool        v3 = true;
    std::string v4 = "A string";

    std::cout &lt;&lt; jsonExporter(v1) &lt;&lt; " "
              &lt;&lt; jsonExporter(v2) &lt;&lt; " "
              &lt;&lt; jsonExporter(v3) &lt;&lt; " "
              &lt;&lt; jsonExporter(v4) &lt;&lt; "\n";
}
...
 12  13.5  true  "A string"</code></pre>
<p>The built-in types <code>integer/float/bool/std::string</code> are serialalable out of the box. You may notice a couple of notable exceptions <code>char</code> and <code>char*</code>. The <code>char</code> type is not supported as it is very easily confused with an integer and <code>char*</code> is not supported because I did not want to encourage C-Strings when <code>std::string</code> is available (sorry).</p>
<p>Note: I know this is not very useful by itself. Bare with me it becomes useful when you start composing types.</p>

    
    

    
    <h3 id="StandardContainers">Standard Containers</h3>
    
        <pre><code class="C++ language-C++">#include "ThorSerialize/JsonThor.h"
#include "ThorSerialize/SerUtil.h"

using ThorsAnvil::Serialize::jsonExporter;
using ThorsAnvil::Serialize::jsonImporter;

int main()
{
    std::vector&lt;int&gt;    data = {1,2,3,4,5,6,7};
    std::cout &lt;&lt; jsonExporter(data) &lt;&lt; "\n";
}
...
 [ 1, 2, 3, 4, 5, 6, 7]</code></pre>
<p>The standard library container types are all supported. You simply need to include <code>#include "ThorSerialize/SerUtil.h"</code>.</p>
<ul>
<li><code>std::array&lt;T,N&gt;</code></li>
<li><code>std::list&lt;T&gt;</code></li>
<li><code>std::vector&lt;T, Allocator&gt;</code></li>
<li><code>std::deque&lt;T, Allocator&gt;</code></li>
<li><code>std::pair&lt;A,B&gt;</code></li>
<li><code>std::set&lt;K&gt;</code></li>
<li><code>std::multiset&lt;K&gt;</code></li>
<li><code>std::map&lt;K,V&gt;</code></li>
<li><code>std::multimap&lt;K,V&gt;</code></li>
<li><code>std::tuple&lt;Args...&gt;</code></li>
<li><code>std::unordered_set&lt;K,V&gt;</code></li>
<li><code>std::unordered_multiset&lt;K&gt;</code></li>
<li><code>std::unordered_map&lt;K,V&gt;</code></li>
<li><code>std::unordered_multimap&lt;K,V&gt;</code></li>
<li><code>std::initializer_list&lt;T&gt;</code></li>
<li><code>std::unique_ptr&lt;T&gt;</code></li>
</ul>

    
    

    
    <h3 id="Enum">Enum</h3>
    
        <pre><code class="C++ language-C++">#include "ThorSerialize/JsonThor.h"
#include "ThorSerialize/Traits.h"

using ThorsAnvil::Serialize::jsonExporter;
using ThorsAnvil::Serialize::jsonImporter;

enum Color { red, green, blue };
ThorsAnvil_MakeEnum(Color, red, green, blue);

int main()
{
    Color c = red;
    std::cout &lt;&lt; jsonExporter(c) &lt;&lt; "\n";
}
...
 "red"</code></pre>
<p>In C++ enums are serialized as integer types. This can work but you loose meaning in this translation. It also binds you contractually to never changing the order of any enum items in the type.</p>
<p>The ThorsSerializer library provides you a mechanism to stream the type as a string. This maintains its symantic meaning while in the JSON format and when de-serialized is converted back to the correct enum value automatically.</p>
<p>For each enum type that you want to serialize simply use <code>ThorsAnvil_MakeEnum()</code> macros to declare the enum and all valid streamable values in the enum range. You simply need to include #include "ThorSerialize/Traits.h".</p>

    
    

    
    <h3 id="Structure">Structure</h3>
    
        <pre><code class="C++ language-C++">// Shirt.h
#include "ThorSerialize/Traits.h"
struct Shirt
{
    int     red;
    int     green;
    int     blue;
};
ThorsAnvil_MakeTrait(Shirt, red, green, blue);</code></pre>
<pre><code class="C++ language-C++">#include "ThorSerialize/JsonThor.h"
#include "Shirt.h"

using ThorsAnvil::Serialize::jsonExporter;
using ThorsAnvil::Serialize::jsonImporter;

int main()
{
    Shirt          shirt{10, 20, 45};
    std::cout &lt;&lt; jsonExporter(shirt) &lt;&lt; "\n";
}
...
    {
        "red": 10,
        "green": 20,
        "blue": 45
    }</code></pre>
<p>In C++ structures are not serializable by default (but often have the appropriate stream operators defined). The advantage of ThorsSerializer library is that it adds a serialization feature to a class without altering the class in any way. This is achieved by building a <code>Serialization::Traits&lt;&gt;</code> type for your class. We will go into more detail on how this works in the implementation section.</p>
<p>The easiest way to build the appropriate <code>Serialization::Traits&lt;&gt;</code> type is to use the macro <code>ThorsAnvil_MakeTrait()</code> naming the type and all members you want to serialize as part of the object. You simply need to include #include "ThorSerialize/Traits.h".</p>
<h4 id="private-members">Private Members</h4>
<pre><code class="C++ language-C++">// TeamMember.h
#include "Shirt.h"
class TeamMember
{
    std::string     name;
    int             score;
    int             damage;
    Shirt           team;
    public:
    TeamMember(std::string const&amp; name, int score, int damage, Shirt const&amp; team)
        : name(name)
          , score(score)
          , damage(damage)
          , team(team)
    {}
    // Define the trait as a friend to get accesses to private Members.
    friend class ThorsAnvil::Serialize::Traits&lt;TeamMember&gt;;
};
ThorsAnvil_MakeTrait(TeamMember, name, score, damage, team);</code></pre>
<pre><code class="C++ language-C++">#include "ThorSerialize/JsonThor.h"
#include "TeamMember.h"

using ThorsAnvil::Serialize::jsonExporter;
using ThorsAnvil::Serialize::jsonImporter;

int main()
{
    TeamMember          mark("mark", 10, 5, Shirt{66, 42, 23});
    std::cout &lt;&lt; jsonExporter(mark) &lt;&lt; "\n";
}
...
    {
        "name": "mark",
        "score": 10,
        "damage": 5,
        "team":
        {
            "red": 66,
            "green": 42,
            "blue": 23
        }
    }</code></pre>
<p>If you have a class/struct were the members that need to be serialized are private then there is no automatic accesses for the ThorsSerializer library to these members. To give the library accesses your class must declare the <code>Serialization::Traits&lt;&gt;</code> type as a friend of the class. This will allow the class to directly accesses these members and both read/write them during the serialization/de-serialization processes.</p>
<h4 id="inheritance">Inheritance</h4>
<pre><code class="C++ language-C++">// ExtendedTeamMember.h
#include "TeamMember.h"
class ExtendedTeamMember: public TeamMember
{
    bool    extension;
    public:
        ExtendedTeamMember(std::string const&amp; name, int score, int damage, Shirt const&amp; team, bool ex)
            : TeamMember(name, score, damage, team)
            , extension(ex)
        {}
    friend class ThorsAnvil::Serialize::Traits&lt;ExtendedTeamMember&gt;;
};
ThorsAnvil_ExpandTrait(TeamMember, ExtendedTeamMember, extension);</code></pre>
<pre><code class="C++ language-C++">#include "ThorSerialize/JsonThor.h"
#include "ExtendedTeamMember.h"

using ThorsAnvil::Serialize::jsonExporter;
using ThorsAnvil::Serialize::jsonImporter;

int main()
{
    ExtendedTeamMember          rangers("Rangers", 10, 5, Shirt{66, 42, 23}, true);
    std::cout &lt;&lt; jsonExporter(rangers) &lt;&lt; "\n";
}
...
    {
        "name": "Rangers",
        "score": 10,
        "damage": 5,
        "team":
        {
            "red": 66,
            "green": 42,
            "blue": 23
        },
        "extension": true
    }</code></pre>
<p>The only difference from a base type is that we use <code>ThorsAnvil_ExpandTrait()</code> rather than <code>ThorsAnvil_MakeTrait()</code>. The difference between these two is that <code>ThorsAnvil_ExpandTrait()</code> takes the parent class as the first parameter followed by the child type as the second parameter.</p>
<h4 id="multiple-inheritance">Multiple Inheritance</h4>
<pre><code class="C++ language-C++">#include "ThorSerialize/JsonThor.h"
#include "ThorSerialize/Traits.h"

using ThorsAnvil::Serialize::jsonExporter;
using ThorsAnvil::Serialize::jsonImporter;

struct Base1
{
    int         data;
};
struct Base2
{
    std::string name;
};
struct Object: public Base1, public Base2
{
    bool        good;
};
ThorsAnvil_MakeTrait(Base1, data);
ThorsAnvil_MakeTrait(Base2, name);

// The macro ThorsAnvil_ExpandTrait() only allows you to declare 1 base type name.
// To get around this limitation you need place both base types into `Serialize::Parents&lt;&gt;` template.
// This can then be used as the parent type in the macro ThorsAnvil_ExpandTrait()‚ê£
using Base1Base2Parent = ThorsAnvil::Serialize::Parents&lt;Base1, Base2&gt;;
ThorsAnvil_ExpandTrait(Base1Base2Parent, Object, good);

int main()
{
    Object  object{12, "Test", true};
    std::cout &lt;&lt; jsonExporter(object) &lt;&lt; "\n";
}
...
    {
        "data": 12,
        "name": "Test",
        "good": true
    }</code></pre>
<p>Multiple enheritance is a tiny bit of a hack.  <br />
Multiple parent types must be combined using the template class <code>ThorsAnvil::Serialize::Parents</code> and then passed to the <code>ThorsAnvil_ExpandTrait()</code> macro as if that was the parent type.</p>

    
    

    
    <h3 id="Pointers">Pointers</h3>
    
        <pre><code class="C++ language-C++">#include "ThorSerialize/JsonThor.h"
#include "ThorSerialize/SerUtil.h"
#include "TeamMember.h"


using ThorsAnvil::Serialize::jsonExporter;
using ThorsAnvil::Serialize::jsonImporter;

int main()
{
    std::unique_ptr&lt;TeamMember&gt;     data;
    std::cout &lt;&lt; jsonExporter(data) &lt;&lt; "\n";
    std::cout &lt;&lt; jsonExporter(data.get()) &lt;&lt; "\n";

    data.reset(new TeamMember{"Tim", 33, 2, Shirt{12, 13, 14}});
    std::cout &lt;&lt; jsonExporter(data) &lt;&lt; "\n";
    std::cout &lt;&lt; jsonExporter(data.get()) &lt;&lt; "\n";
}
...
 null
 null

    {
        "name": "Tim",
        "score": 33,
        "damage": 2,
        "team":
        {
            "red": 12,
            "green": 13,
            "blue": 14
        }
    }

    {
        "name": "Tim",
        "score": 33,
        "damage": 2,
        "team":
        {
            "red": 12,
            "green": 13,
            "blue": 14
        }
    }</code></pre>
<p>No extra work needs to be done to serialize pointers. If the pointer is <code>nullptr</code> it will serialize to the <code>null</code> type of the serialization format. If the pointer is not null then it will serialize as an object.</p>
<h4 id="stdunique_ptr">std::unique_ptr</h4>
<p>The <code>std::unique_ptr&lt;&gt;</code> behaves just like a pointer during serialization.</p>
<h4 id="stdshared_ptr">std::shared_ptr</h4>
<p>The <code>std::shared_ptr</code> is not currently supported.</p>
<h4 id="polymorphic-objects">Polymorphic Objects</h4>
<pre><code class="C++ language-C++">#include "ThorSerialize/JsonThor.h"
#include "TeamMember.h"

using ThorsAnvil::Serialize::jsonExporter;
using ThorsAnvil::Serialize::jsonImporter;

struct Vehicle
{
    Vehicle(){}
    Vehicle(int speed)
        : speed(speed)
    {}
    virtual ~Vehicle() {}
    int     speed;
    ThorsAnvil_PolyMorphicSerializer(Vehicle);
};
struct Car: public Vehicle
{
    Car(){}
    Car(int speed, std::string const&amp; make)
        : Vehicle(speed)
          , make(make)
    {}
    std::string     make;
    ThorsAnvil_PolyMorphicSerializer(Car);
};
struct Bike: public Vehicle
{
    Bike(){}
    Bike(int speed, int stroke)
        : Vehicle(speed)
          , stroke(stroke)
    {}
    int     stroke;
    ThorsAnvil_PolyMorphicSerializer(Bike);
};
ThorsAnvil_MakeTrait(Vehicle, speed);
ThorsAnvil_ExpandTrait(Vehicle, Car, make);
ThorsAnvil_ExpandTrait(Vehicle, Bike, stroke);

int main()
{
    Vehicle* v = new Bike(12,3);
    std::cout &lt;&lt; jsonExporter(v) &lt;&lt; "\n";
}
...
    {
        "__type": "Bike",
        "speed": 12,
        "stroke": 3
    }</code></pre>
<p>Polymorphic objects are supported. <strong>BUT</strong> require an intrusive change in the type. To mark objects as polymorphic you need to add the macro <code>ThorsAnvil_PolyMorphicSerializer()</code>. This macro adds a couple of virtual methods to your class (but no data members). Additonally the resulting JSON has an extra field <code>__ type</code> that contains the name of the type. This allows the serialization library to dynamically create the correct type at runtime.</p>

    
    

    
    <h3 id="Value">Value</h3>
    
        <pre><code class="C++ language-C++">#include "ThorSerialize/JsonThor.h"
#include "ThorSerialize/Traits.h"

using ThorsAnvil::Serialize::jsonExporter;
using ThorsAnvil::Serialize::jsonImporter;

struct ID
{
    int id;
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, ID const&amp; data) {return s &lt;&lt; data.id;}
    friend std::istream&amp; operator&gt;&gt;(std::istream&amp; s, ID&amp; data)       {return s &gt;&gt; data.id;}
};
ThorsAnvil_MakeTraitCustom(ID);

int main()
{
    ID  id{23};
    std::cout &lt;&lt; jsonExporter(id) &lt;&lt; "\n";
}
...
 23</code></pre>
<p>In situations where your class already has appropriate input and output operators (that generate JSON like values (Bool,Integer/Float/String) then you can simply declare your type as serializeable using the macro <code>ThorsAnvil_MakeTraitCustom()</code>.</p>

    
    


    


    

    
    <h1 id="Implementation">Implementation</h1>
    
        

    
    
        
    
    <h2 id="Traits">Traits</h2>
    
        <pre><code class="C++ language-C++">namespace ThorsAnvil
{
    namespace Serialize
    {

template&lt;typename T&gt;
class Traits
{
    public:
        static constexpr TraitType type = TraitType::Invalid;
};

    }
}</code></pre>
<p>The serialization processes is built around around a traits class <code>Traits&lt;T&gt;</code> that is specialized for each type. This is similar in technique to the <code>std::iterator_traits&lt;&gt;</code> used by the standard library.</p>
<p>The generic (and thus default) <code>Traits&lt;T&gt;</code> has a single member <code>type</code> that has the value <code>TraitType::Invalid</code>.</p>
<p>The <code>type</code> member of the <code>Traits&lt;&gt;</code> specialization indicates how the member will be serialized/de-serialized and defines what other members of the <code>Traits&lt;&gt;</code> class are needed for that speialization.</p>
<p>The following values are allowed: <code>{Invalid, Parent, Value, Map, Array, Enum, Pointer, Serialize}</code></p>

    
    
        
    
    <h3 id="TraitsValue">Traits Value</h3>
    
        <pre><code class="C++ language-C++">template&lt;&gt;
class Traits&lt;FundamentType&gt;
{
    public:
        static constexpr TraitType type = TraitType::Value;
};</code></pre>
<p>This is used for all the fundamental types. These types use the <code>ParserInterface</code> and <code>PrinterInterface</code> to serialize/de-serialize. You should only use this value if your value can be parsed via: <code>ParserInterface::getValue()</code> and printed via <code>PrinterInterface::addValue()</code>.</p>

    
    

    
    <h3 id="TraitsEnum">Traits Enum</h3>
    
        <pre><code class="C++ language-C++">template&lt;&gt;
class Traits&lt;Enum_Type&gt;
{
    public:
        static constexpr TraitType type = TraitType::Enum;

        static char const* const*   getValues();
        static Enum_Type            getValue(std::string const&amp; val, std::string const&amp; msg);
};</code></pre>
<p>In this case ThorsSerializer expects the <code>Traits&lt;T&gt;</code> class to have two extra static methods: <code>getValues()</code> and <code>getValue()</code>.</p>
<ul>
<li><code>getValues()</code>  <br />
Is used for serializing the value by providing an array of <code>char const*</code> that represent the text version of the enum value.</li>
<li><code>getValue()</code>  <br />
Is used for deserializing a specific string into a specifc enum value.</li>
</ul>
<pre><code class="C++ language-C++">    ThorsAnvil_MakeEnum(&lt;EnumType&gt;, &lt;EnumValues&gt;...)</code></pre>
<p>The easy way to generate the <code>Traits&lt;&gt;</code> specialization for an enum with these fields is via the macro <code>ThorsAnvil_MakeEnum()</code>.</p>

    
    

    
    <h3 id="TraitsSerialize">Traits Serialize</h3>
    
        <pre><code class="C++ language-C++">template&lt;&gt;
class Traits&lt;StremableType&gt;
{
    public:
        static constexpr TraitType type = TraitType::Serialize;
};</code></pre>
<p>In this case ThorsSerializer expects the object to serialize itself via <code>operator&lt;&lt;</code> and <code>operator&gt;&gt;</code>. The resulting value should be a simple JSON value (Bool/Integer/Float/String).</p>
<pre><code class="C++ language-C++">    ThorsAnvil_MakeTraitCustom(&lt;SerializableType&gt;);</code></pre>
<p>The easy way to generate the <code>Traits&lt;&gt;</code> specialization for a Serialize type is via the macro <code>ThorsAnvil_MakeTraitCustom()</code>.</p>

    
    

    
    <h3 id="TraitsPointer">Traits Pointer</h3>
    
        <pre><code class="C++ language-C++">template&lt;typename T&gt;
class Traits&lt;T*&gt;
{
    public:
        static constexpr TraitType type = TraitType::Pointer;
        static T*   alloc();
        static void release(T* p);
};</code></pre>
<p>In this case ThorsSerializer expects the <code>Traits&lt;T&gt;</code> class to have two extra static methods: <code>alloc()</code> and <code>release()</code>.</p>
<ul>
<li><code>alloc()</code>  <br />
Is used to allocate an object of type T</li>
<li><code>release()</code>  <br />
Is used to release an onbject of type T that was allocated via the <code>alloc()</code> function.</li>
</ul>
<p>If you simply want to use <code>new</code> and <code>delete</code> then the default partial specialization of thie object works out of the box with no extra configuration needed.</p>
<h5 id="thorsanvil_pointerallocator">ThorsAnvil_PointerAllocator</h5>
<pre><code class="C++ language-C++">strict MyDataMemoryPool
{
    MyData* alloc();
    void release(MyData*);
};
ThorsAnvil_PointerAllocator(MyData, MyDataMemoryPool);</code></pre>
<p>The easy way to generate the <code>Traits&lt;&gt;</code> specialization for a pointer that has its own allocators is via the macro <code>ThorsAnvil_PointerAllocator()</code>.</p>

    
    

    
    <h3 id="TraitsMap">Traits Map</h3>
    
        <pre><code class="C++ language-C++">template&lt;&gt;
class Traits&lt;MapType&gt;
{
    public:
        static constexpr TraitType type = TraitType::Map;   // or TraitType::Parent

        static ExtractorType const&amp; getMembers();
};
//  ExtractorType   =&gt; std::tuple&lt;Item...&gt;
//                  or MemberExtractor
//
//  Item    =&gt;  std::pair&lt;char const*, M*&gt;              // M*            pointer to a static member of the class.
//          =&gt;  std::pair&lt;char const*, M MapType::*&gt;    // M MapType::*  pointer to a member of the class
//              struct MemberExtractor
//              {
//                  void operator()(PrinterInterface&amp; printer, ArrayType const&amp; object) const;
//                  void operator()(ParserInterface&amp; parser,  std::string const&amp; key, ArrayType&amp; object) const;
//              };</code></pre>
<p>If the <code>Traits&lt;&gt;::type</code> is <code>TraitType::Map</code> or <code>TraitType::Parent</code> then the <code>Traits&lt;&gt;</code> specialization is expected to have a static <code>getMembers()</code> method that returns an <code>Extractor</code> object (see below for details).</p>
<p>When serializing an object where the <code>Traits&lt;&gt;::type</code> is <code>TraitType::Map</code> or <code>TraitType::Parent</code> the library will call <code>openMap()</code> on the <code>printerInterface</code> (generates a '{' in JSON) and conversely will call <code>closeMap()</code> (generates a '}' in JSON) after all the members have been serialized. Conversily when de-serializing into an object with these <code>Traits&lt;&gt;::type</code> the parser will expect an mapOpen/mapClose marker (in JSON '{' amd '}' respecively).</p>
<h4 id="tuple-of-pair">Tuple of pair</h4>
<pre><code class="C++ language-C++">    ThorsAnvil_MakeTrait(DataType, ...);
    ThorsAnvil_ExpandTrait(ParentType, DataType, ...);</code></pre>
<p>If the <code>getMembers()</code> method returns a <code>std::tuple</code> with a set of <code>std::pair&lt;&gt;</code>. Then each pair represents a member of the map that needs to be serialized. The <code>pair&lt;&gt;::first</code> represents the key and is serialized as string and when de-serializing we search the <code>std::tuple</code> to see if we can match the key that was read from the input. The <code>pair&lt;&gt;::second</code> is a pointer to the object that represents the value. A recursive call to de-serialize the value is made.</p>
<p>The easy way to generate the <code>Traits&lt;&gt;</code> specialization for an Map with  fields is via the macro <code>ThorsAnvil_MakeTrait()</code> or <code>ThorsAnvil_ExpandTrait()</code>.</p>
<h4 id="memberextractor">MemberExtractor</h4>
<p>If the <code>getMembers()</code> method returns any other type it is expected to have an interface that matchs the <code>MemberExtractor</code> definition. The method using <code>PrinterInterface</code> is called once and is expected to serialize the object using this interface. The method using the <code>ParserInterface</code> is called after each key has been extracted and is expected to de-serialize the value directly into the destination object.</p>

    
    

    
    <h3 id="TraitsArray">Traits Array</h3>
    
        <pre><code class="C++ language-C++">template&lt;&gt;
class Traits&lt;ArrayType&gt;
{
    public:
        static constexpr TraitType type = TraitType::Array;

        struct MemberExtractor
        {
            void operator()(PrinterInterface&amp; printer, ArrayType const&amp; object) const;
            void operator()(ParserInterface&amp; parser, std::size_t index, ArrayType&amp; object) const;
        };
        static ExtractorType const&amp; getMembers()
};</code></pre>
<p>If the <code>Traits&lt;&gt;::type</code> is <code>TraitType::Array</code> then the <code>Traits&lt;&gt;</code> specialization is expected to have a static <code>getMembers()</code> method that returns an <code>MemberExtractor</code> object (see below for details).</p>
<p>When serializing an object where the <code>Traits&lt;&gt;::type</code> is <code>TraitType::Array</code> the library will call <code>openArray()</code> on the <code>printerInterface</code> (generates a '[' in JSON) and conversely will call <code>closeArray()</code> (generates a ']' in JSON) after all the members have been serialized. Conversily when de-serializing into an object with these <code>Traits&lt;&gt;::type</code> the parser will expect an arrayOpen/arrayClose marker (in JSON '[' amd ']' respecively).</p>
<p>The method using <code>PrinterInterface</code> is called once and is expected to serialize the object using this interface. The method using the <code>ParserInterface</code> is called for each new value that is available on the stream and is expected to de-serialize the value directly into the destination object. Note: each time it is called the index is passed.</p>

    
    


    


    

    
    <h1 id="APiGenerated">APi Generated</h1>
    
        
<dl>
<dt>NameSpace:</dt><dd>ThorsAnvil::Serialize</dd>
<dt>Headers:</dt><dd>ThorSerialize</dd>

    
        <dt>BinaryThor.h</dt><dd>
            <ul>
            
                
            
            
                
                    <li>Exporter&lt;Binary<T&gt;, T> binExporter
                    
                    ()
                    
                    </li>
                
                    <li>Importer&lt;Binary<T&gt;, T> binImporter
                    
                    ()
                    
                    </li>
                
            
            </ul>
        </dd>
    
        <dt>JsonThor.h</dt><dd>
            <ul>
            
                
            
            
                
                    <li>Exporter&lt;Json, T&gt; jsonExporter
                    
                    ()
                    
                    </li>
                
                    <li>Importer&lt;Json, T&gt; jsonImporter
                    
                    ()
                    
                    </li>
                
            
            </ul>
        </dd>
    
        <dt>YamlThor.h</dt><dd>
            <ul>
            
                
            
            
                
                    <li>Exporter&lt;Yaml, T&gt; yamlExporter
                    
                    ()
                    
                    </li>
                
                    <li>Importer&lt;Yaml, T&gt; yamlImporter
                    
                    ()
                    
                    </li>
                
            
            </ul>
        </dd>
    

</dl>


    
    
        
    
    <h2 id="binExporter">binExporter</h2>
    
        <div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorSerialize/BinaryThor.h</div><div></div></div>
            <div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Serialize</div><div></div></div>
            
            <div class="classRow"><div class="classItem">Template: </div><div class="classValue">template&lt;typename T&gt;</div><div></div></div>
            
        </div>
        
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Return Value: Exporter<Binary<T>, T></div></div>
            <div class="classRow"><div class="classDesc">Object that can be passed to operator<< for serialization.</div></div>
        </div>
        
        
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Parameters</div></div>
        </div>
        <div class="classBlock">
            
            <div class="classRow">&nbsp;<div class="classItem">T const& value</div><div class="classValue">The object to be serialized.</div></div>
            
            <div class="classRow">&nbsp;<div class="classItem">bool catchExceptions</div><div class="classValue"></div></div>
            
        </div>
        
    </div>
</div>




    
    
        

    

    
    <h2 id="binImporter">binImporter</h2>
    
        <div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorSerialize/BinaryThor.h</div><div></div></div>
            <div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Serialize</div><div></div></div>
            
            <div class="classRow"><div class="classItem">Template: </div><div class="classValue">template&lt;typename T&gt;</div><div></div></div>
            
        </div>
        
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Return Value: Importer<Binary<T>, T></div></div>
            <div class="classRow"><div class="classDesc">Object that can be passed to operator>> for de-serialization.</div></div>
        </div>
        
        
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Parameters</div></div>
        </div>
        <div class="classBlock">
            
            <div class="classRow">&nbsp;<div class="classItem">T& value</div><div class="classValue">The object to be de-serialized.</div></div>
            
            <div class="classRow">&nbsp;<div class="classItem">bool catchExceptions</div><div class="classValue"></div></div>
            
        </div>
        
    </div>
</div>




    
    
        

    

    
    <h2 id="jsonExporter">jsonExporter</h2>
    
        <div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorSerialize/JsonThor.h</div><div></div></div>
            <div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Serialize</div><div></div></div>
            
            <div class="classRow"><div class="classItem">Template: </div><div class="classValue">template&lt;typename T&gt;</div><div></div></div>
            
        </div>
        
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Return Value: Exporter<Json, T></div></div>
            <div class="classRow"><div class="classDesc">Object that can be passed to operator<< for serialization.</div></div>
        </div>
        
        
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Parameters</div></div>
        </div>
        <div class="classBlock">
            
            <div class="classRow">&nbsp;<div class="classItem">T const& value</div><div class="classValue">The object to be serialized.</div></div>
            
            <div class="classRow">&nbsp;<div class="classItem">PrinterInterface::OutputType characteristics</div><div class="classValue">Default: is verbose and logical. Stream: remove all white space.</div></div>
            
            <div class="classRow">&nbsp;<div class="classItem">bool catchExceptions</div><div class="classValue"></div></div>
            
        </div>
        
    </div>
</div>




    
    
        

    

    
    <h2 id="jsonImporter">jsonImporter</h2>
    
        <div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorSerialize/JsonThor.h</div><div></div></div>
            <div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Serialize</div><div></div></div>
            
            <div class="classRow"><div class="classItem">Template: </div><div class="classValue">template&lt;typename T&gt;</div><div></div></div>
            
        </div>
        
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Return Value: Importer<Json, T></div></div>
            <div class="classRow"><div class="classDesc">Object that can be passed to operator>> for de-serialization.</div></div>
        </div>
        
        
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Parameters</div></div>
        </div>
        <div class="classBlock">
            
            <div class="classRow">&nbsp;<div class="classItem">T& value</div><div class="classValue">The object to be de-serialized.</div></div>
            
            <div class="classRow">&nbsp;<div class="classItem">ParserInterface::ParseType parseStrictness</div><div class="classValue">Weak: ignore missing extra fields. Strict: Any missing or extra fields throws exception.</div></div>
            
            <div class="classRow">&nbsp;<div class="classItem">bool catchExceptions</div><div class="classValue"></div></div>
            
        </div>
        
    </div>
</div>




    
    
        

    

    
    <h2 id="yamlExporter">yamlExporter</h2>
    
        <div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorSerialize/YamlThor.h</div><div></div></div>
            <div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Serialize</div><div></div></div>
            
            <div class="classRow"><div class="classItem">Template: </div><div class="classValue">template&lt;typename T&gt;</div><div></div></div>
            
        </div>
        
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Return Value: Exporter<Yaml, T></div></div>
            <div class="classRow"><div class="classDesc">Object that can be passed to operator<< for serialization.</div></div>
        </div>
        
        
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Parameters</div></div>
        </div>
        <div class="classBlock">
            
            <div class="classRow">&nbsp;<div class="classItem">T const& value</div><div class="classValue">The object to be serialized.</div></div>
            
            <div class="classRow">&nbsp;<div class="classItem">PrinterInterface::OutputType characteristics</div><div class="classValue">Default: is verbose and logical. Stream: remove all white space.</div></div>
            
            <div class="classRow">&nbsp;<div class="classItem">bool catchExceptions</div><div class="classValue"></div></div>
            
        </div>
        
    </div>
</div>




    
    
        

    

    
    <h2 id="yamlImporter">yamlImporter</h2>
    
        <div class="classTable">
    <div class="classLayout">
        <div class="classBlock">
            <div class="classRow"><div class="classItem">Header:   </div><div class="classValue">ThorSerialize/YamlThor.h</div><div></div></div>
            <div class="classRow"><div class="classItem">NameSpace:</div><div class="classValue">ThorsAnvil::Serialize</div><div></div></div>
            
            <div class="classRow"><div class="classItem">Template: </div><div class="classValue">template&lt;typename T&gt;</div><div></div></div>
            
        </div>
        
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Return Value: Importer<Yaml, T></div></div>
            <div class="classRow"><div class="classDesc">Object that can be passed to operator>> for de-serialization.</div></div>
        </div>
        
        
        <div class="classBlock">
            <div class="classRow"><div class="classSect">Parameters</div></div>
        </div>
        <div class="classBlock">
            
            <div class="classRow">&nbsp;<div class="classItem">T& value</div><div class="classValue">The object to be de-serialized.</div></div>
            
            <div class="classRow">&nbsp;<div class="classItem">ParserInterface::ParseType parseStrictness</div><div class="classValue">Weak: ignore missing extra fields. Strict: Any missing or extra fields throws exception.</div></div>
            
            <div class="classRow">&nbsp;<div class="classItem">bool catchExceptions</div><div class="classValue"></div></div>
            
        </div>
        
    </div>
</div>




    
    
        

    


    


    </div>
    <div class="dark-box"></div>
</div>

    <script src="javascripts/prism.js"></script>
</body>


</html>
